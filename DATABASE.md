# DATABASE

### 0. 데이터베이스를 사용하는 이유

- 데이터베이스의 정의?

```
데이터베이스란 원하는 기능을 동작시키기 위해 마땅히 저장해야하는 정보의 집합이다.
```

<br>

- DBMS(Database Management System)란?

```
데이터베이스를 관리하기위한 프로그램. 사용자와 직접적으로 상호작용하기 보다는 사용자가 만든 프로그램과 상호작용하며 실행된다.
```

<br>

- 데이터베이스의 특징?

```markdown
1. 실시간 접근성: 비정형적이고 예측할 수 없는 질의에 대해 실시간으로 응답할 수 있어야 한다.

2. 지속적인 변화: 데이터가 지속적으로 삽입(Insert), 삭제(Delete), 갱신(Update)되며 항상 최신 상태를 유지해야 한다.

3. 동시 공용: 여러 사용자가 동시에 동일한 데이터를 접근하고 사용할 수 있도록 설계되어야 한다.

4. 내용에 의한 참조: 데이터를 검색할 때, 데이터의 물리적 위치(주소나 저장경로)가 아니라 데이터의 내용(값이나 속성)에 기반하여 검색해야 한다.
```

<br>

- 파일이 아닌 데이터베이스를 사용하는 이유?

```markdown
1. 데이터 일관성 및 무결성 제공이 어렵다

- 레이스 컨디션 문제가 발생할 여지가 있고, 이로 인해 데이터의 일관성이 훼손되기 쉽다.
- 파일에 명시된 데이터에 결함이 없음을 일일이 검사할 수 없다.

2. 불필요한 중복 저장이 많아진다

- 학과.txt, 학생.txt라는 파일이 있다고 가정했을 때 두 테이블의 공통된 속성이 있더라도 모든 속성을 중복해서 저장하게 된다.

3. 데이터 변경 시 연관 데이터 변경이 어렵다.

- 학과.txt의 한 학과 이름을 변경하면 학생.txt에서 해당 학과의 이름을 모두 변경해야 할 것이다.

4. 정교한 검색이 어렵다.

- 파일 내 검색은 문자열 검색에 국한된 경우가 많다.
- '나이가 25살 이상인 컴퓨터과학과인 서울 거주자'와 같은 정교한 검색의 경우 파일로는 조회가 어렵다.

5. 백업 및 복구가 어렵다.

- DBMS는 백업과 복구 기능을 제공하지만 단순 파일 입출력으로 이를 따라가기 어렵다.
```

<br>
<br>

### 1. Key

- Key(기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.

```markdown
1. 기본키

- 테이블에서 각 행을 고유하게 식별할 수 있는 단일 속성, 혹은 속성들의 집합
- 무결성을 유지(NOT NULL)
- 후보키 중 하나를 선택한 것이므로 유일성과 최소성을 만족함

2. 후보키

- 기본키로 선택될 수 있는 모든 속성 또는 속성들의 조합
- 유일성과 최소성을 만족

3. 대체키

- 후보키 중 기본키로 선택되지 않은 나머지 키

4. 외래키

- 한 테이블에서 다른 테이블의 기본 키를 참조하는 속성
- 참조 무결성을 유지하기 위해 참조되는 기본키의 값과 일치하거나 NULL이어야 함

5. 슈퍼키

- 테이블에서 행을 고유하게 식별할 수 있는 하나 이성의 속성들의 집합
- 기본키와 후보키도 슈퍼키에 포함됨
- 유일성을 보장하지만 최소성을 보장하지는 않음

* 최소성?
  키에 포함된 속성 중 하나를 제거했을 때 더 이상 데이터를 고유하게 식별할 수 없게 되면 최소성을 만족하는 것임
```

<br>

- 기본키는 수정이 가능한가요?

```markdown
기본키는 수정이 가능하지만 다음과 같은 사항에 주의해야한다.

1. 참조 무결성 위반: 다른 테이블에서 해당 기본키를 참조하는 외래키가 있을 때 주의. `CASCADE UPDATE`를 통해 해결할 수 있으나 몇몇 RDBMS에서는 이를 지원하지 않는다.
2. 데이터 일관성 문제: 데이터의 고유성을 보장하기 때문에 잘못 수정하면 일관성이 깨짐
3. 성능 저하: 모든 테이블은 기본적으로 하나의 Clustered index를 갖게 되고, 이는 PK 값을 기준으로 물리적으로 정렬이 되어있는 tree의 구조이다. 만약 PK에 수정이 일어나면 변경된 값을 바탕으로 다시 물리적인 재정렬이 필요하다.
```

<br>

- 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?

```markdown
1. MySQL은 기본 키 없이도 행을 식별할 수 있도록 다음과 같은 메커니즘을 활용한다.

- InnoDB를 사용하면 숨겨진 클러스터형 인덱스(Row ID)를 생성한다.
- 해당 Row ID는 6바이트 크기의 정수로, 데이터 삽입시 자동 증가한다.

2. 유일성 보장이 필요하지 않은 경우

- 로그 데이터와 같이 유일성이 필요 없는 데이터인 경우에 설정하지 않아도 무방하다.

3. 외래키 제약조건 미사용

- 기본키가 없는 테이블은 외래키로 사용하지 않는 경우 외에는 문제가 되지 않는다.
```

<br>

- 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?

```markdown
- 인덱스가 자동으로 생성되어 조회 성능이 향상된다.
- 삽입, 업데이트 작업에서 중복 검사 및 인덱스 변경으로 인해 성능이 약간 저화될 수 있다.
```

<br>

### 2. RDB와 NoSQL의 차이에 대해 설명해 주세요.

- NoSQL의 강점과, 약점이 무엇인가요?
- RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)
- NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.

### 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

- ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
- 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
- 읽기에는 트랜잭션을 걸지 않아도 될까요?

### 4. 트랜잭션 격리 레벨에 대해 설명해 주세요.

- 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
- 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
- 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?

### 5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.

- 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
- 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
- ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
- 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
- 그렇다면 외래키는요?
- 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
- 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
- (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
- Index의 자료구조에는 어떤것들이 있나요?

### 6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.

- 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?
- 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
- 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
- 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?

### 7. 정규화가 무엇인가요?

- 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
- 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.
- 정규화의 장점?
- 정규화의 단점?
- 어떤 상황에서 반정규화를 하는게 좋은지 설명해 주세요.

### 8. View가 무엇이고, 언제 사용할 수 있나요?

- 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?

### 9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.

- INNER 조인과 OUTER 조인의 차이점을 설명해보세요.
- 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.
- 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?
- 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?
- 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.

### 10. B-Tree와 B+Tree에 대해 설명해 주세요.

- 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?
- DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?
- 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.

### 11. DB Locking에 대해 설명해 주세요.

- 교착상태란 무엇인가요? 교착상태 발생의 필요충분 조건은 무엇인가요?
- Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.
- 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?

### 12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?

- DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?

### 13. Schema가 무엇인가요?

- Schema의 3계층에 대해 설명해 주세요.

### 14. DB의 Connection Pool에 대해 설명해 주세요.

- DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.

### 15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.

- 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?
- COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(\*), COUNT(column) 의 동작 과정에는 차이가 있나요?

### 16. SQL Injection에 대해 설명해 주세요.

- 그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?

### 17. 프로시저란 무엇인가요?

### 18. 트리거(Trigger)에 대해 설명해주세요.

### 19. 옵티마이저(Optimizer)에 대해 설명해주세요.

### 20. DB 튜닝(Tuning)이 무엇인지 설명해주세요.

- 튜닝의 3단계에 대해 설명해주세요.

### 21. GROUP BY의 역할에 대해 설명해주세요.

### 22. DELETE, TRUNCATE, DROP의 차이를 설명해주세요.

### 23. HAVING과 WHERE의 차이를 설명해주세요.

### 24. JOIN에서 ON과 WHERE의 차이를 설명해주세요.
