# DATABASE

### 0. 데이터베이스를 사용하는 이유

- 데이터베이스의 정의?

```
데이터베이스란 원하는 기능을 동작시키기 위해 마땅히 저장해야하는 정보의 집합이다.
```

<br>

- DBMS(Database Management System)란?

```
데이터베이스를 관리하기위한 프로그램. 사용자와 직접적으로 상호작용하기 보다는 사용자가 만든 프로그램과 상호작용하며 실행된다.
```

<br>

- 데이터베이스의 특징?

```markdown
1. 실시간 접근성: 비정형적이고 예측할 수 없는 질의에 대해 실시간으로 응답할 수 있어야 한다.

2. 지속적인 변화: 데이터가 지속적으로 삽입(Insert), 삭제(Delete), 갱신(Update)되며 항상 최신 상태를 유지해야 한다.

3. 동시 공용: 여러 사용자가 동시에 동일한 데이터를 접근하고 사용할 수 있도록 설계되어야 한다.

4. 내용에 의한 참조: 데이터를 검색할 때, 데이터의 물리적 위치(주소나 저장경로)가 아니라 데이터의 내용(값이나 속성)에 기반하여 검색해야 한다.
```

<br>

- 파일이 아닌 데이터베이스를 사용하는 이유?

```markdown
1. 데이터 일관성 및 무결성 제공이 어렵다

- 레이스 컨디션 문제가 발생할 여지가 있고, 이로 인해 데이터의 일관성이 훼손되기 쉽다.
- 파일에 명시된 데이터에 결함이 없음을 일일이 검사할 수 없다.

2. 불필요한 중복 저장이 많아진다

- 학과.txt, 학생.txt라는 파일이 있다고 가정했을 때 두 테이블의 공통된 속성이 있더라도 모든 속성을 중복해서 저장하게 된다.

3. 데이터 변경 시 연관 데이터 변경이 어렵다.

- 학과.txt의 한 학과 이름을 변경하면 학생.txt에서 해당 학과의 이름을 모두 변경해야 할 것이다.

4. 정교한 검색이 어렵다.

- 파일 내 검색은 문자열 검색에 국한된 경우가 많다.
- '나이가 25살 이상인 컴퓨터과학과인 서울 거주자'와 같은 정교한 검색의 경우 파일로는 조회가 어렵다.

5. 백업 및 복구가 어렵다.

- DBMS는 백업과 복구 기능을 제공하지만 단순 파일 입출력으로 이를 따라가기 어렵다.
```

<br>

- 데이터베이스 언어(DDL, DML, DCL)에 대해 설명해주세요.

```markdown
- DDL (Data Definition Language): 데이터베이스 구조를 정의, 수정, 삭제하는 언어 (alter, create, drop)
- DML (Data Manipulation Language): 데이터베이스내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어 (select, insert, update, delete)
- DCL (Data Control Language): 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어 (commit, rollback, grant, revoke)
```

<br>
<br>

### 1. Key

- Key(기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.

```markdown
1. 기본키

- 테이블에서 각 행을 고유하게 식별할 수 있는 단일 속성, 혹은 속성들의 집합
- 무결성을 유지(NOT NULL)
- 후보키 중 하나를 선택한 것이므로 유일성과 최소성을 만족함

2. 후보키

- 기본키로 선택될 수 있는 모든 속성 또는 속성들의 조합
- 유일성과 최소성을 만족

3. 대체키

- 후보키 중 기본키로 선택되지 않은 나머지 키

4. 외래키

- 한 테이블에서 다른 테이블의 기본 키를 참조하는 속성
- 참조 무결성을 유지하기 위해 참조되는 기본키의 값과 일치하거나 NULL이어야 함

5. 슈퍼키

- 테이블에서 행을 고유하게 식별할 수 있는 하나 이성의 속성들의 집합
- 기본키와 후보키도 슈퍼키에 포함됨
- 유일성을 보장하지만 최소성을 보장하지는 않음

* 최소성?
  키에 포함된 속성 중 하나를 제거했을 때 더 이상 데이터를 고유하게 식별할 수 없게 되면 최소성을 만족하는 것임
```

<br>

- 기본키는 수정이 가능한가요?

```markdown
기본키는 수정이 가능하지만 다음과 같은 사항에 주의해야한다.

1. 참조 무결성 위반

- 다른 테이블에서 해당 기본키를 참조하는 외래키가 있을 때 주의.
- `CASCADE UPDATE`를 통해 해결할 수 있으나 몇몇 RDBMS에서는 이를 지원하지 않는다.

2. 데이터 일관성 문제

- 데이터의 고유성을 보장하기 때문에 잘못 수정하면 일관성이 깨짐

3. 성능 저하

- 모든 테이블은 기본적으로 하나의 Clustered index를 갖게 되고, 이는 PK 값을 기준으로 물리적으로 정렬이 되어있는 tree의 구조이다
- 만약 PK에 수정이 일어나면 변경된 값을 바탕으로 다시 물리적인 재정렬이 필요하다.
```

<br>

- 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?

```markdown
1. MySQL은 기본 키 없이도 행을 식별할 수 있도록 다음과 같은 메커니즘을 활용한다.

- InnoDB를 사용하면 숨겨진 클러스터형 인덱스(Row ID)를 생성한다.
- 해당 Row ID는 6바이트 크기의 정수로, 데이터 삽입시 자동 증가한다.

2. 유일성 보장이 필요하지 않은 경우

- 로그 데이터와 같이 유일성이 필요 없는 데이터인 경우에 설정하지 않아도 무방하다.

3. 외래키 제약조건 미사용

- 기본키가 없는 테이블은 외래키로 사용하지 않는 경우 외에는 문제가 되지 않는다.
```

<br>

- 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?

```markdown
- 인덱스가 자동으로 생성되어 조회 성능이 향상된다.
- 삽입, 업데이트 작업에서 중복 검사 및 인덱스 변경으로 인해 성능이 약간 저화될 수 있다.
```

<br>
<br>

### 2. RDB와 NoSQL의 차이에 대해 설명해 주세요.

```markdown
1. 스키마

- RDB는 고정된 스키마를 사용하며 모든 데이터가 2차원의 행과 열로 정의되어 있다
- NoSQL은 스키마가 유연하거나 아예 없으며 다양한 형태의 데이터 모델을 지원한다. (Key-Value, Document, Graph, ...)

2. 확장성

- RDB는 수직 확장(Vertical Scaling)에 강하다. 서버(하드웨어)의 성능 업그레이드 후 처리능력을 향상시키는 방식이다. 수평 확장은 어렵고 샤딩과 같은 복잡한 구조를 도입해야 한다.
- NoSQL은 수평 확장(Horizontal Scaling)에 강하다. 여러 대의 서버를 연결하여 데이터를 분산 저장할 수 있어 대규모 트래픽과 데이터 처리에 적합하다.

3. ACID & CAP, BASE

- RDB는 ACID(Atomicity, Consistency, Isolation, Durability) 속성을 따른다. 트랜잭션이 정확하고 신뢰성있게 처리된다.
- NoSQL은 `CAP` (Consistency, Availability, Partition tolerance) 이론을 따른다.
  - Consistency: 분산된 노드 중 어느 노드로 접근하더라도 데이터 값이 같아야함
  - Availability: 클러스터링된 노드 중 하나의 노드가 실패하더라도 정상적으로 요청을 처리
  - Partition Tolerance: 클러스터링 노드간에 통신하는 네트워크가 장애가 나더라도 정상적으로 서비스 수행
- 또한 ACID 속성보다는 `BASE` (Basically Available, Soft state, Eventually consistent) 모델을 채택하여 즉시 일관성보다는 최종 일관성을 보장한다.
  - Basically Available: 다수의 실패에도 항상 가용성을 보장, Optimistic Locking 사용
  - Soft state: 쓰기 일관성이 있을 필요가 없으며 서로 다른 복제본이 항상 상호 일관성이 있을 필요도 없음, 분산 노드간 업데이트는 데이터가 노드에 도달한 시점에 갱신
  - Eventually Consistent: 일시적으로 일관성이 깨져도 최종적으로는 일관성을 보장함

4. 쿼리 방식

- RDB는 SQL을 사용한다.
- NoSQL은 특정 데이터에 따라 다양한 쿼리 방법을 제공하며, 정형화된 쿼리 언어를 따르지 않는다.

5. 사용 용도

- RDB는 정형 데이터 관리에 적합하며 은행 거래 시스템이나 ERP, 회계 시스템 등에서 많이 사용된다. 정확한 트랜잭션 처리와 무결성을 보장에 적합하다.
- NoSQL은 비정형 데이터나 대규모 데이터 처리에 적합하며 소셜미디어, 로그데이터 처리, 빅데이터 분석 등에서 많이 사용된다.

* NoSQL은 트랜잭션을 지원하지 않나?
  NoSQL 데이터베이스는 일부 트랜잭션을 지원하지만, 전체 ACID 속성을 강제하지 않으며, 대신 최종 일관성(Eventual Consistency)을 보장한다. 대부분 BASE 모델을 따르며, 트랜잭션 처리에서 가용성과 분산을 우선시한다.
```

<br>

- NoSQL의 장단점?

```markdown
# 강점:

1. 확장성: 수평 확장(horizontal scaling)에 유리
2. 유연한 데이터 모델: 비정형 데이터(예: JSON, 문서)를 효율적으로 처리
3. 고가용성 및 분산 처리: 분산 시스템에서 데이터 가용성을 높이고, 자동 복구가 가능
4. 빠른 읽기/쓰기 성능: 대규모 데이터를 다룰 때 빠른 읽기/쓰기 성능을 제공

# 약점:

1. 트랜잭션의 일관성 부족: ACID 속성을 완전하게 보장하지 않음, 일부 NoSQL 시스템은 최종 일관성만 제공
2. 복잡한 쿼리 제한: 복잡한 JOIN이나 집계 함수를 사용할 수 없거나 제한적
3. 데이터 중복: 데이터를 여러 곳에 복제하거나 분산할 수 있지만, 이는 데이터 중복과 무결성 문제를 유발할 수 있음
4. 학습 곡선: 다양한 데이터 모델(문서, 키-값, 그래프 등)을 이해하고 적절히 사용하기 위한 학습이 필요
```

<br>

- RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)

```markdown
1. 스키마 기반 구조: 고정된 스키마의 제약으로 데이터 삽입, 수정 시 스키마 검사
2. 데이터 정합성 검사: 다양한 제약조건(ex: 외래키 제약)으로 인해 정합성 검사
3. 트랜잭션 관리: ACID 속성을 강하게 보장하여 동시성 처리와 같은 작업에서 추가적인 부하
4. 조인 연산: 테이블이 크고 조인할 데이터가 많을 때 성능이 저하될 수 있음
```

<br>

- NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.

```markdown
AI 작업 로그 저장시에 MongoDB를 선택

- 유연한 스키마: 로그의 형식을 유연하게 변경하는 것이 가능해야 했음
- 대규모 데이터: 대량으로 쌓이는 로그들을 빠르게 I/O
```

<br>
<br>

### 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

```markdown
# 트랜잭션의 정의

- 데이터베이스와 데이터 스토리지 시스템에서 한 단위의 작업으로 취급되는 모든 작업
- 트랜잭션은 완전히 완료되기도 하고 전혀 완료되지 않을 수 있음

# ACID

- `Atomicity(원자성)`: 트랜잭션 내의 작업이 모두 성공하거나 모두 실패하거나 둘 중 하나의 상태를 유지한다.
  - A 계좌에서 10만 원을 출금하고 B 계좌에 10만 원을 입금하는 작업이 하나의 트랜잭션으로 실행된다.
  - 만약 A 계좌에서 출금은 성공했지만 B 계좌에 입금이 실패했다면, 트랜잭션 전체가 취소되어 A 계좌에서도 출금 작업이 롤백된다.
- `Consistency(일관성)`: 트랜잭션 실행 전후의 데이터베이스 상태가 항상 일관된 상태를 유지한다.
  - 재고 10개에서 2개를 판매하면, 재고(8) + 판매량(7)은 항상 초기 값(15)과 일치해야 한다.
- `Isolation(고립성)`: 여러 트랜잭션이 동시에 실행되더라도 각 트랜잭션은 서로 간섭하지 않고 독립적으로 처리된다.
  - 하나의 트랜잭션이 완료되기 전에는 다른 트랜잭션이 간섭할 수 없다. 첫 번째 트랜잭션이 완료된 후 재고가 0으로 설정되면, 두 번째 트랜잭션은 구매를 시도했을 때 실패한다.
- `Durability(영속성)`: 트랜잭션이 성공적으로 완료된 후에는 시스템 오류가 발생하더라도 그 결과가 영구적으로 저장된다.
  - 고객이 항공권을 예약하고 결제가 성공적으로 완료되면, 시스템 오류가 발생하거나 서버의 재부팅 이후에도 예약 상태가 유지된다.
```

<br>

- ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?

```markdown
1. Write-Ahead Logging (WAL)

- 트랜잭션 변경 내용을 DB에 적용하기 전 로그파일에 기록하여 장애 발생시에도 복구함

2. Checkpointing

- 특정 시점마다 DB 상태를 디스크에 저장
- 시스템 장애시 마지막 체크포인트와 로그파일을 사용해 데이터를 복구

3. Redo 로그

- 커밋 시점의 모든 데이터 변경사항을 저장한 Redo 로그를 통해 이를 기반으로
  커밋된 트랜잭선을 다시 실행하며 데이터베이스를 복구할 수 있음
```

<br>

- 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?

```markdown
- 스프링의 `@Transaction` 애노테이션은 메서드 안에서 실행되는 쿼리를 하나로 묶어준다.
  - 같은 클래스 내에서 메서드 간 호출은 트랜잭션이 적용되지 않을 수 있다. (AOP 우회)
  - 런타임 예외(RuntimeException) 발생 시 롤백된다.
  - @Transactional(isolation = Isolation.READ_COMMITTED)와 같이
    격리 수준을 옵셔널하게 정의할 수 있음
- 여러 작업을 하나의 단위로 묶어야할 때 유용하게 사용할 수 있다.
  - 예를 들어 재고 감소, 주문 저장, 결제 완료를 하나의 트랜잭션으로 묶어서 처리할 수 있다.
  - 결제 실패시 재고 감소와 주문 저장도 롤백된다.
```

<br>

- 읽기에는 트랜잭션을 걸지 않아도 될까요?

```markdown
- 일반적인 읽기 작업에서는 트랜잭션을 생략해도 무방하다.
- 읽기 작업에 트랜잭션이 필요한 경우

1. 읽기 작업 중 다른 트랜잭션에서 데이터가 변경되면 안되는 경우
2. 오래 걸리는 대규모 데이터 읽기 작업 중 데이터가 변경되면 안되는 경우
3. 읽기-쓰기 혼합 작업이 있는 경우
```

<br><br>

### 4. 트랜잭션 격리 레벨에 대해 설명해 주세요.

- 격리 레벨 (Isolation Level)이란?

```markdown
- 여러 트랜잭션이 동시에 일어날 때 각 트랜잭션이 서로 간섭하지 않고
  독립적으로 수행될 수 있도록 보장하는 규칙
- 격리수준이 높아질수록 동시 처리 성능도 떨어진다
```

<br>

- 트랜잭션 격리 수준에 따른 이상현상

```markdown
- Dirty Read: 어떤 트랜잭션에서 처리한 작업이 커밋되지 않았는데도
  다른 트랜잭션에서 볼 수 있는 현상
- Non-Repeatable Read: 트랜잭션이 **동일한 데이터**를 여러 번 읽었을 때
  그 사이에 다른 트랜잭션이 데이터를 변경하여 서로 다른 결과를 반환하는 현상
- Phantom Read: 한 트랜잭션이 **동일한 조건**으로 여러 번 데이터를 읽었을 때
  다른 트랜잭션이 데이터를 삽입하거나 삭제하여 **데이터 집합**의 레코드 수가 달라지는 현상
```

| **특징**      | **Non-repeatable Read**                              | **Phantom Read**                                              |
| ------------- | ---------------------------------------------------- | ------------------------------------------------------------- |
| **발생 시점** | 같은 데이터를 여러 번 읽을 때, 데이터 값이 달라짐.   | 동일한 조건의 데이터를 여러 번 읽을 때, 데이터 집합이 달라짐. |
| **원인**      | 다른 트랜잭션이 읽은 데이터를 수정하거나 삭제함.     | 다른 트랜잭션이 데이터를 삽입하거나 삭제함.                   |
| **문제의 예** | 같은 데이터의 값이 두 번 읽을 때 다르게 나오는 현상. | 같은 조건에 맞는 데이터의 개수나 내용이 달라지는 현상.        |

<br>
<br>

- 4가지 트랜잭션 격리 수준

```markdown
1. `READ UNCOMMITTED`

- 가장 낮은 격리 수준으로 Dirty Read, Non-Repeatable Read, Phantom Read
  모두 허용
- 성능이 가장 빠르지만 데이터 일관성이 보장되지 않음

2. `READ COMMITTED`

- 한 트랜잭션에서 커밋된 데이터만 읽을 수 있음
- Dirty Read만 방지함
- 일반적인 격리수준으로 오라클 같은 시스템에서 기본값으로 사용

3. `REPEATABLE READ`

- 트랜잭션 동안 동일한 데이터를 읽었을 때 항상 동일한 결과를 보장
- Dirty Read, Non-Repeatable Read를 방지함
- **MySQL의 InnoDB 엔진 기본값** 으로 사용

4. `SERIALIZABLE`

- 가장 높은 격리 수준으로 모든 트랜잭션이 순차적으로 실행되는것처럼 동작
- Dirty Read, Non-repeatable Read, Phantom Read 모두 방지됨
- 동시성 처리 성능이 가장 낮아질 수 있으며 가장 엄격한 데이터 일관성 보장
```

| **격리 수준**    | **Dirty Read** | **Non-repeatable Read** | **Phantom Read** | **성능**  |
| ---------------- | -------------- | ----------------------- | ---------------- | --------- |
| READ UNCOMMITTED | 허용           | 허용                    | 허용             | 가장 빠름 |
| READ COMMITTED   | 방지           | 허용                    | 허용             | 빠름      |
| REPEATABLE READ  | 방지           | 방지                    | 허용             | 보통      |
| SERIALIZABLE     | 방지           | 방지                    | 방지             | 느림      |

<br>
<br>

- 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?

```markdown
- PostgreSQL, Oracle은 4개의 격리 수준을 모두 지원한다.
- MySQL (InnoDB), SQLite는 READ UNCOMMITTED 격리 수준을 제공하지 않는다.
- DBMS에 따라 같은 격리 수준을 구현하는 방식에 차이가 있을 수 있다.
- 또한 DBMS의 설계 철학(성능을 중요시 할것인가, 높은 데이터 일관성을 보장할것인가)에 따라
  지원하는 격리 수준이 다를 수 있다.
```

<br>

- 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.

```markdown
# Undo

- 트랜잭션이 수행되기 전의 상태를 기록한 로그
- 트랜잭션이 롤백될 때 이전 상태로 되돌리기 위해 사용됨
- UPDATE나 DELETE 작업이 수행될 때 기록되며 Atomicity와 연관이 깊음
- Repeatable Read 격리 수준에서 중요한 역할을 함

# Redo

- 트랜잭션 커밋 후 변경된 데이터의 최종 상태를 저장함
- 예를 들어 INSERT, UPDATE, DELETE 작업 후 변경 내용이 기록됨
- 트랜잭션 지속성과 복구를 보장하는데 사용
- 트랜잭션이 COMMIT 될 때 변경된 데이터를 영구적으로 디스크에 반영하기 위해
  Redo 로그를 사용하며, 이후 시스템 장애 시 Redo 로그를 통해 복구가 가능
```

| **특징**              | **Undo 영역**                                          | **Redo 영역**                                              |
| --------------------- | ------------------------------------------------------ | ---------------------------------------------------------- |
| **목적**              | 트랜잭션 롤백 및 읽기 일관성 유지                      | 트랜잭션의 지속성 보장 및 복구                             |
| **저장 내용**         | 트랜잭션의 변경 이전 값                                | 트랜잭션의 커밋된 변경 후 값                               |
| **트랜잭션 상태**     | 트랜잭션 롤백 시 원래 데이터로 되돌리기 위한 정보 저장 | 트랜잭션 커밋 후 데이터베이스에 영구적으로 반영되는 데이터 |
| **장애 발생 시 역할** | 롤백을 통해 트랜잭션 중간 상태를 원래 상태로 복구      | 커밋된 트랜잭션을 복구하여 데이터베이스 복구               |

<br>
<br>

- 데이터베이스 엔진(스토리지 엔진)이 무엇인가요?

```markdown
# 스토리지 엔진이란

- DBMS가 데이터를 CRUD 하는 데 사용되는 기본 소프트웨어 컴포넌트

# MySQL의 주요 스토리지 엔진

1. InnoDB (Default)

- ACID를 지원하는 트랜잭션 기반 스토리지 엔진
- 외래 키 제약을 지원하여 RDBMS의 일관성 보장
- 자동 복구 기능을 제공
- 행 수준 잠금(Row-level locking)을 사용하여 동시성 처리에 강함
  - 여러 트랜잭션이 동일한 테이블에 접근하더라도 각 트랜잭션이 서로 다른 행에 접근하므로 충돌을 최소화
  - 교착 상태(Deadlock) 문제가 발생 가능:
    여러 트랜잭션이 서로 다른 행을 잠그고 이후 서로 잠금이 필요한 다른 행을 기다리게 될 수 있음

2. MyISAM

- 트랜잭션을 지원하지 않음
- 빠른 읽기 성능, 낮은 디스크 I/O를 제공하지만 신뢰성이 떨어짐
- 테이블 수준 잠금(Table-level locking)을 사용하여 동시성 처리에 제한이 있음
  (여러 트랜잭션이 동시에 테이블에 접근하려고 하면 다른 트랜잭션들이 대기해야 하므로 병목 현상 발생)
```

<br>

<br>

### 5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.

- 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
- 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
- ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
- 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
- 그렇다면 외래키는요?
- 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
- 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
- (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
- Index의 자료구조에는 어떤것들이 있나요?

### 6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.

- 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?
- 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
- 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
- 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?

### 7. 정규화가 무엇인가요?

- 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
- 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.
- 정규화의 장점?
- 정규화의 단점?
- 어떤 상황에서 반정규화를 하는게 좋은지 설명해 주세요.

### 8. View가 무엇이고, 언제 사용할 수 있나요?

- 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?

### 9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.

- INNER 조인과 OUTER 조인의 차이점을 설명해보세요.
- 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.
- 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?
- 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?
- 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.

### 10. B-Tree와 B+Tree에 대해 설명해 주세요.

- 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?
- DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?
- 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.

### 11. DB Locking에 대해 설명해 주세요.

- 교착상태란 무엇인가요? 교착상태 발생의 필요충분 조건은 무엇인가요?
- Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.
- 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?

### 12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?

- DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?

### 13. Schema가 무엇인가요?

- Schema의 3계층에 대해 설명해 주세요.

### 14. DB의 Connection Pool에 대해 설명해 주세요.

- DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.

### 15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.

```markdown
# Table Full Scan

- 특정 조건 없이 테이블에 속한 블록 전체를 읽는 것
- 시퀀셜 엑세스와 Multiblock I/O 방식으로 디스크 블록을 읽음
- 많은 데이터를 읽을 때 적합

# Index Range Scan

- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 가능
- 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식
- 랜덤 액세스(인덱스로 바로 접근)와 Single Block I/O 방식으로 디스크 블록을 읽음
- 큰 테이블에서 소량 데이터를 검색할 때 적합
```

<br>

- 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?

```markdown
1. 적용 가능한 인덱스가 없는 경우

- 결합 인덱스의 선두 칼럼이 존재하지 않음
  ex) 결합 인덱스 (A, B) 가 있다고 하더라도 WHERE B = ? 라고만 쿼리에서 조건을 걸면 인덱스를 사용하지 않음
- 칼럼에 대한 연산/함수 적용
  ex) SELECT \* FROM employees WHERE LOWER(name) = 'smith';
- 인덱스가 비효율적이거나 불완전한 경우

2. 넓은 범위의 데이터 액세스

- 조회하려는 데이터가 전체 테이블의 20-25% 이상을 차지할 경우, 옵티마이저는 인덱스 스캔보다 Full Scan이 더 효율적이라고 판단

3. 소량의 테이블 액세스

- 테이블의 크기가 매우 작아서 DB_FILE_MULTIBLOCK_READ_COUNT 이내의 블록으로 구성된 경우

4. 병렬 처리 액세스

- 병렬처리는 Full Table Scan이 더 효율적
```

<br>

- COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(\*), COUNT(column) 의 동작 과정에는 차이가 있나요?

```
- COUNT(1)과 COUNT(\*)는 기본적으로 같은 방식으로 동작하며, 둘 다 테이블을 전부 스캔하면서 모든 행을 대상으로 카운트함
  - 데이터를 읽지 않고 레코드 수만 불러오기 때문에 빠른 성능을 보임
- COUNT(column)은 인덱스를 사용할 수 있다면 해당 열에 대해 범위 스캔을 하며, NULL 값이 없는 데이터만 카운트
  - 실제 데이터를 읽어야 하고 NULL 체크 로직이 추가되어 COUNT(*)보다 성능이 떨어짐
  - 열에 인덱스가 없는 경우에는 테이블을 전부 스캔해야 하므로 성능에 차이가 있을 수 있음
```

<br>

### 16. SQL Injection에 대해 설명해 주세요.

- 그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?

<br>

### 17. 프로시저란 무엇인가요?

```sql
"""
특정 작업이나 기능을 수행하는 SQL 코드 블록
한 번 작성해 저장해 두면 이후에 호출하여 반복적으로 실행 가능
"""

-- 프로시저 정의
DELIMITER //

CREATE PROCEDURE example_procedure(IN param1 INT, OUT result INT)
BEGIN
    -- 작업 로직
    SELECT param1 * 2 INTO result;
END //

DELIMITER ;

-- 프로시저 호출
CALL example_procedure(10, @output);
SELECT @output; -- 출력값 확인
```

<br>

- 프로시저의 장점과 단점?

```markdown
# 장점

1. 성능 향상

- 프로시저의 최초 실행 시 최적화 상태로 컴파일이 되며, 그 이후 프로시저 캐시에 저장된다.
- 만약 해당 프로세스가 여러 번 사용될 때, 다시 컴파일 작업을 거치지 않고 캐시에서 가져오게 된다.
- 프로시저는 데이터베이스 서버에서 실행되므로, 클라이언트와의 네트워크 왕복 횟수를 줄일 수 있음

2. 트랜잭션 관리 용이

- 프로시저 내에서 여러 개의 SQL 문을 하나의 트랜잭션으로 묶어 실행할 수 있어, 데이터 일관성을 유지하기 용이

3. 보안:

- 사용자가 직접 테이블에 접근하는 것을 제한하고, 프로시저를 통해 필요한 작업만 수행

# 단점

1. 의존성 증가

- 프로시저가 비즈니스 로직을 처리하게 되면, 애플리케이션의 특정 부분이 데이터베이스에 강하게 의존하게 될 수 있음

2. 이식성 문제

- 프로시저는 데이터베이스에 종속적이므로, 특정 DBMS에 맞게 작성된 프로시저는 다른 DBMS로 이식할 때 수정이 필요할 수 있음

3. 성능 저하

- 문자 또는 숫자 연산에서 프로그래밍 언어보다 성능이 떨어짐
```

<br>

### 18. 트리거(Trigger)에 대해 설명해주세요.

### 19. 옵티마이저(Optimizer)에 대해 설명해주세요.

```markdown
# 정의

SQL 쿼리 수행 작업을 가장 효율적으로 수행할 수 있는,
최적의 데이터 액세스 경로를 선택해주는 DBMS의 핵심 엔진

# 유형

1. RBO (Rule-Based Optimizer)

- 정해진 규칙에 따라 실행 계획을 선택함
- 예를 들어 "인덱스가 있으면 무조건 사용한다"와 같은 규칙을 따름
- 현대적 시스템에서는 잘 사용되지 않음

2. CBO (Cost-Based Optimizer)

- 실행 계획의 비용을 계산하여 가장 효율적인 계획 선택
- 데이터베이스의 통계 정보를 활용하여 더 나은 성능 보장
- 대부분의 현대적인 DBMS에서 사용됨

# 최적화 단계

1. 쿼리 수행을 위해 후보군이 될만한 실행계획들을 찾아냄
2. Data Dictionary에 미리 수집해 둔 통계 정보를 이용해 각 실행계획의 예상비용 산정
3. 최저 비용을 나타내는 실행 계획을 선택

- Data dictionary란?
  메타데이터를 저장하는 구조화된 정보의 집합
  ex) MySQL의 INFORMATION_SCHEMA
  `SELECT TABLE_NAME
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'database_name';`
```

<br>

### 20. DB 튜닝(Tuning)이 무엇인지 설명해주세요.

```markdown
데이터베이스의 성능을 최적화하고 효율적인 데이터 처리를 위해 데이터베이스 시스템을 조정하는 작업
```

<br>

- 튜닝의 3단계에 대해 설명해주세요.

```markdown
1. DB 설계 튜닝 (모델링 관점)

- 데이터의 구조와 설계에 초점을 맞추고, 데이터베이스 내 데이터의 저장 방식 및 관계를 최적화
- 데이터 모델링, 인덱스 설계, 데이터파일, 테이블 스페이스 설계
- 반정규화, 분산파일 배치 (Sharding, Replication 등의 기법 사용)

2. DBMS 튜닝 (환경 관점)

- 데이터베이스가 효율적으로 운영될 수 있도록 DBMS의 운영 환경, 시스템 자원(메모리, CPU, I/O 등)을 최적화
- 메모리 버퍼 크기나 데이터 블록 크기 등을 조정
- Buffer 및 Cache 크기 조정

3. SQL 튜닝 (APP 관점)

- 애플리케이션의 SQL 쿼리 및 데이터베이스와의 상호작용 관점
- Join, Indexing, SQL Execution Plan
- Hash, Join
```

<br>

### 21. GROUP BY의 역할에 대해 설명해주세요.

### 22. DELETE, TRUNCATE, DROP의 차이를 설명해주세요.

### 23. HAVING과 WHERE의 차이를 설명해주세요.

### 24. JOIN에서 ON과 WHERE의 차이를 설명해주세요.
