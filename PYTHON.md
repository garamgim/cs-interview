https://www.geeksforgeeks.org/python-interview-questions/

### Python

- 파이썬의 특징은 무엇입니까?

```markdown
- 간결하고 쉬운 문법으로 설계되어 있어 가독성이 좋다. 따라서 협업이 쉽고 유지보수가 용이하다.
- 넓은 범위의 라이브러리를 제공함으로써 개발이 간편해진다.
  데이터 분석이나 AI 등의 광범위한 분야의 라이브러리를 제공함으로써 새로운 기술을 도입하는것이 쉬워지고, 다양한 도메인에서 사용할 수 있다.
```

<br>

- 파이썬은 컴파일 언어인가, 인터프리터 언어인가?

```markdown
- 파이썬은 컴파일언어와 인터프리터 언어의 장점을 모두 결합한 하이브리드 언어다.
  일반적으로 파이썬은 인터프리터 언어로 분류되는데, 이는 최종 실행 단계에서 동적 해석이 이루어지기 때문이다.
- 그러나 실제로는 다음과 같은 과정을 거친다.
  - 컴파일: `.py` 소스 코드가 바이트코드로 컴파일된다. 이는 `.pyc` 파일 형태로 저장될 수 있으며, 이 단계에서 문법 오류가 발생하면 프로그램이 중단된다.
  - 인터프리터: 컴파일된 바이트 코드는 파이썬 가상 머신 (PVM)에 의해 실행된다. PVM은 인터프리터로 작동하며, 바이트코드를 한줄씩 읽고 실행한다. 이 과정에서 런타임 에러가 발생하면 프로그램이 중단된다.
- JVM은 바이트코드를 기계어로 변환해 실행하지만 파이썬은 바이트코드를 해석하며 실행한다는 특성을 가지고 있다.
  바이트코드가 한줄씩 실행되므로 실행 속도가 JAVA보다 느릴 수 있다.
```

<br>

- 파이썬에서 메모리 관리는 어떻게 이루어지나?

```markdown
- 파이썬은 참조카운팅을 기본으로 사용하며, 참조카운트가 0이되면 즉시 메모리를 해제한다.
- 참조 카운팅만으로는 순환 참조 (두 객체가 서로를 참조하여 참조 카운트가 0이 되지 않는 경우)를 처리할 수 없다.
  이 경우 파이썬은 GC 모듈을 통해 추가적인 가비지 컬렉션을 수행한다.
- 자바와 달리 개발자가 명시적으로 가비지 컬렉션을 호출할 수 있다.
  그러나 JVM처럼 다양한 GC 알고리즘을 제공하지 않으며, 튜닝할 여지가 적다.
```

<br>

- 리스트와 튜플의 차이?

```markdown
# 리스트

- 가변 객체이다.
- 동적 배열(공간 부족의 경우 새 메모리 공간으로 복사 + 메타데이터)로 구현되어있어 메모리를 더 많이 소모한다.
- 순회 중 요소가 수정될 가능성 등을 고려하여 이를 안전하게 처리하기 위한 장치로 인해 속도가 느리다.

# 튜플

- 불변 객체이다.
- 크기가 고정되어 있어 더 적은 메모릴르 소모하다.
- 순회 중에 요소가 변경되지 않을 것을 보장하기 때문에 추가적인 검사나 관리가 필요 없어 속도가 더 빠르다.
  또한 불변성으로 인해 메모리 접근 패턴이 예측 가능하여 CPU 캐시의 공간을 더 효율적으로 사용할 수 있다.
```

<br>

- 가변 객체가 해싱이 안되는 이유?

```markdown
- 해시 함수는 같은 입력값에 대해 항상 같은 해시값을 반환해야 하기 때문에 입력값이 불변이어야만 신뢰할 수 있다.
```

<br>

- 파이썬에서 `__init__()`이란?

```markdown
- 객체가 생성될 때 자동으로 호출되는 초기화 메서드다.
- 객체의 속성을 설정하거나 초기값을 할당하는데 사용된다.
```

<br>

- 파이썬의 상속과 자바의 상속이 다른점?

```markdown
- 파이썬은 다중 상속을 지원한다. 즉 하나 이상의 부모 클래스로부터 상속을 받을 수 있다.
```

<br>

- 제너레이터가 무엇인가?

```markdown
# 정의

제너레이터는 iterable한 객체를 생성하는 특별한 종류의 함수다.
한번에 모든 값을 메모리에 로딩하는 대신, 필요할 때마다 값을 하나씩 생성해서 반환한다.
이는 메모리 효율성을 크게 개선할 수 있다.

# 특징

- `yield` 키워드 사용:
  - yield는 함수의 실행을 멈추고 호출자에게 값을 반환한다. 함수는 이후 호출 시 해당 지점을 기억하고 다시 실행한다.
  - yield는 return과 유사하지만, 함수 실행을 끝내지 않고 그 상태를 보존하며 중단한다.
- Iterator와의 차이:
  - Generator는 Iterator의 한 종류이나, `__iter__()`와 `__next()__` 메서드를 직접 구현할 필요 없이 yield를 사용하면 자동으로 이터레이터를 생성한다.
  - Iterator는 데이터를 하나씩 반환하는 객체지만, Generator는 데이터 생성의 로직을 담당하는 함수다.
- 지연 평가 (Lazy Evaluation):
  - 값을 한번에 모두 생성하지 않고 next() 호출 시마다 하나씩 생성한다.
```

```python
def count_up_to(limit):
    count = 1
    while count <= limit:
        yield count  # 현재 값 반환하고 함수 실행을 멈춤
        count += 1

# 제너레이터 객체 생성
counter = count_up_to(5)

# 제너레이터에서 값 하나씩 꺼내기
print(next(counter))  # 1
print(next(counter))  # 2
print(next(counter))  # 3
print(next(counter))  # 4
print(next(counter))  # 5
# 더 이상 값이 없으면 StopIteration 예외 발생
```

<br>

- `yield`의 다양한 사용 예시

```python
def read_file_line_by_line(filename):
    with open(filename, 'r') as file:
        for line in file:
            yield line.strip()  # 각 줄을 반환

# 파일에서 한 줄씩 읽기
file_generator = read_file_line_by_line('sample.txt')

for line in file_generator:
    print(line)
```

```markdown
- read_file_line_by_line 함수는 파일을 한 줄씩 읽어서 반환하는 제너레이터다.
- 파일이 크더라도 한번에 모든 내용을 메모리에 로드하지 않고 필요할때마다 한줄씩 반환함으로써 메모리를 효율적으로 사용한다.
- yield는 각 줄을 반환하고, 함수 실행이 중단된 채로 상태를 유지한다. 루프에서 next() 호출 시 그 상태에서 다시 실행된다.
```

<br>

- Python의 예외처리?

```python
try:
    print("파일 열기")
    # 파일을 여는 코드나, 예외가 발생할 가능성이 있는 코드
    # 예: 파일 열기, 네트워크 연결 등
    result = 10 / 0  # 예외 발생
except ZeroDivisionError:
    print("0으로 나눌 수 없습니다.")
finally:
    print("이 코드는 예외가 발생하든 안 하든 항상 실행됩니다.")
```

<br>

- `with`란 무엇인가?

```markdown
- `with`는 context manager를 사용하여 코드 블록 내에서 리소스를 자동으로 관리할 수 있게 해주는 구문이다.
- 주로 파일을 열거나, 락을 거는 등의 리소스를 다룰 때 사용되며, 코드 블록을 벗어나면 자동으로 해당 리소스를 정리한다.
- 예를 들어, 파일을 열 때 with를 사용하면 파일을 연 후 자동으로 파일을 닫아주기 때문에, 파일을 닫는 코드를 따로 작성할 필요가 없다.
```

```python
with open('example.txt', 'w') as file:
    file.write('Hello, world!')

# 이 코드 블록을 벗어나면 파일이 자동으로 닫힌다.
```
